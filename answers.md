
### Как вы реализовали асинхронное выполнение задач в вашем скрипте?
Для асинхронного выполнения задач я использовал библиотеку `asyncio`, которая позволяет создавать и управлять асинхронными функциями. Основная функция `main` использует `asyncio.run` для запуска асинхронных задач, таких как загрузка содержимого репозитория и вычисление хэшей файлов.

### Какие библиотеки использовались для скачивания содержимого репозитория и для каких целей?
Для скачивания содержимого репозитория я использовал библиотеку `aiohttp`. Она предоставляет асинхронный HTTP-клиент для выполнения запросов, что позволяет эффективно загружать данные без блокировки основного потока выполнения.

### Какие проблемы асинхронности вы сталкивались при выполнении задания и как их решали?
Одной из проблем была корректная обработка исключений в асинхронных функциях. Чтобы избежать прерывания выполнения при ошибках, я использовал блоки `try-except` внутри асинхронных функций для логирования ошибок и продолжения выполнения.

### Как вы организовали скачивание файлов во временную папку?
Для организации скачивания файлов я создал временную папку с помощью `os.makedirs` и скачивал содержимое репозитория в эту папку. После завершения всех операций временная папка и все ее содержимое удаляются с помощью функции `clean_temp_dir`.

### Какие основные требования wemake-python-styleguide вы находите наиболее важными для поддержания качества кода?
Основные требования `wemake-python-styleguide`, которые помогают поддерживать качество кода, включают:
- Ограничение когнитивной сложности функций.
- Ограничение длины строк и количество локальных переменных.
- Использование аннотаций типов для всех функций.
- Соблюдение PEP8 и других стандартов Python.

### Как вы настраивали свой проект для соответствия конфигурации nitpick, указанной в задании? Были ли трудности при настройке?
Я добавил конфигурацию `nitpick` в файл `pyproject.toml`, указав URL стиля для загрузки общих настроек. Трудности возникли при настройке совместимости версий библиотек и устранении конфликтов с устаревшими зависимостями, такими как `flake8-commas`.

### Какие инструменты использовали для измерения 100% покрытия тестами?
Для измерения покрытия тестами я использовал библиотеку `pytest-cov`, которая интегрируется с `pytest` и генерирует отчеты о покрытии кода тестами.

### Какие типы тестов вы написали для проверки функциональности вашего скрипта? (Например, модульные тесты, интеграционные тесты)
Я написал модульные тесты для проверки отдельных функций, таких как загрузка содержимого репозитория и вычисление хэшей файлов. Интеграционные тесты проверяют работу всего процесса, включая создание временной папки, загрузку репозитория и вычисление хэшей.

### Как вы тестировали асинхронный код? Использовали ли вы моки (mocks) или стабы (stubs) для тестирования асинхронных операций?
Для тестирования асинхронного кода я использовал библиотеку `pytest-asyncio`, которая позволяет запускать асинхронные тесты. В некоторых случаях я использовал моки для имитации поведения внешних зависимостей и предотвращения реальных HTTP-запросов во время тестирования.
